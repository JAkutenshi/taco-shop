# Глава 1. Создание проекта и основные элементы Spring-приложения

## Основные аннотации

`@SpringBootApplication` - используется над классом, реализующим `main()` метод. Содержит внутри три других важных аннотации:

- `@EnableAutoConfiguration` - позволяет Spring-у самостоятельно конфигурировать проект;
- `@ComponentScan` - позволяет Spring-у самостоятельно искать классы с аннотацией `@Component` или аннотациями её содержащих (`@Controller`, `@Service` и `@Repository`) и регистрировать такие классы в контексте Spring-приложения (Application Context).
- `@SpringBootConfiguration` - указывает что данный класс может использоваться для конфигурации приложения, частный случай аннотации `@Configuration`.

`@Controller` - компонент, содержащий внутри методы, сопоставляемые соответствующим HTTP-запросам. Является семантической спецификацией аннотации `@Component`.

`@GetMapping('/my/url/route')` - указывает, что аннотируемый метод должен вызываться, при GET-запросе по URL-у `/my/url/route`.

`@SpringBootTest` - аннотация для класса тестирования SpringBoot-приложения.

`@WebMvcTest(MyController.class)` - специальная аннотация, позволяющая проводить тестирования используя контекст SpringMVC. В качестве аргумента передаются классы MVC-контроллеров, контекст которых будет использоваться в тестах.

## Детали реализации View

За View в данном случае выступают шаблоны для генератора Thymeleaf. Метод `home()` в классе `HomeController.class` возвращает строку `home`, которая должна совпасть с именем файла в `src/main/resources/templates/{возвращаемая-строка}.html`. В таком случае, генератор Thymeleaf возьмёт этот файл как шаблон и преобразует в ответный для клиента HTML-документ.

Так же стоит заметить, что `home.html` внутри использует относительную адресацию для задания пути до изображения с логотипом: `th:src="@{/images/home-logo.png}`. Данный путь ищется относительно директории со статическим содержимым приложения, т.е. относительно `/src/main/resources/static/`. Таким образом полный путь до логотипа: `/src/main/resources/static/images/home-logo.png`.

Аналогично можно поступать для указания таблиц стилей:

```html
<head>
    <link rel="stylesheet" th:href="@{/styles/style.css}" />
</head>
```

## Детали реализации тестирования

При реализации тестового сценария мы пытаемся проверить GET-запрос:

- что он возвращает HTTP-Response == 200 (HTTP.OK);
- что в ответ на запрос возвращается View с именем `home`;
- что в ответном html-документе есть слово `Welcome`.

Для этого используется объект `@Autowired MvcMock mvcMock`. IDEA иногда может подчёркивать, эту строку как ошибку, но это баг самой IDE. Можно отключить проверку.

У данного объекта вызываются два метода:

- `perform(...)` - в который передаётся метод того, что требуется сделать;
- `andExpect(...)` - в который передаётся метод, проверяющий ту или иную составляющую ответа на действие выше из `perform(...)`.

В качестве действий и проверок используются следующие статические методы:

- `MockMvcRequestBuilders.get("/my/route")` - выполняет GET-запрос по переданному URL (например `/my/route/`);
- `MockMvcResultMatchers.status()` - возвращает объект статуса выполнения, можно проверить, что ответ является 200, методом `.isOk()`;
- `MockMvcResultMatchers.view()` - возвращает объект с информацией о View, который возвращается с контроллера. Можно проверить, что у View имя совпадает с ожидаемым методом `.name("my-view-name")`;
- `MockMvcResultMatchers.content()` - возвращает объект с содержимым ответа на запрос. Можно проверить строковое представление содержимого на соответствие какому-либо условию при помощи метода `.string(condition)`, где `condition` - проверка из фреймворка `Hamcrest`. `Hamcrest` содержит внутри множество условий и сопоставлений с проверками внутри. Часто используется вместо assert-методов JUnit из-за большей читаемости как кода, так и негативного результата прохождения проверки. Например, для проверки - содержит ли ответный html-документ строку "Welcome" - используется метод `org.hamcrest.Matchers.containsString("Welcome")`.

