# Глава 2. Работа со слоем модели, валидация данных с форм

## Lombok

Lombok - это библиотека аннотаций и плагин для сборки проектов, предоставляющие кодогенерацию рутинного кода,
такого как геттеры-сеттеры или конструкторы, на уровне байт-кода. Автор книги использует данную библиотеку, чтобы 
показать читателю как можно уменьшить объём рутинного кода. Кроме того, Lombok действительно часто используется в 
реальных проектах. У меня есть отторжение к этой библиотеке, а с выходом Java 17 для таких шаблонных иммутабельных POJO,
где автор использует Lombok - можно и лучше использовать Java Records. Тем не менее, чтобы не сильно отходить от книги,
а так же разобрать основы Lombok, который, возможно, может пригодиться в будущем, будем пользоваться им.

### Основные аннотации

`@Slf4j` - добавляет внутри класса создание логгера с именем `log` на основе реализации фасада SLF4J.

`@NotNull` - добавляет проверку на null для отмеченных полей или аргументов методов.

`@Data` - является объединением следующих Lombok-аннотаций:

 - `@ToString` - переопределяет стандартный метод `toString()`;
 - `@EqualsAndHashCode` - переопределяет стандартные методы `equals()` и `hashcode()`;
 - `@Getter` - при использовании @Data применяет @Getter на всех полях класса, генерируя для них геттеры;
 - `@Setter` - при использовании @Data применяет @Setter на всех не константных полях класса, генерируя для них сеттеры;
 - `@RequiredArgsConstructor` - создаёт конструктор с аргументами для константных полей или полей, отмеченных
аннотацией `@NonNull`.

Автор использует лишнюю аннотацию `RequireArgsConstructor` - как видно выше, она же включена в `@Data`.

## MVC-контроллер

### Новые аннотации

На уровне класса контроллера используется аннотация `@RequestMapping("/path")` для упрощения написания путей внутри 
контроллера. В результате те пути, которые пишутся внутри контроллера для обработчиков (например при помощи аннотации `@GetMapping("/secondary-path")`) будут работать относительно того, который указан в `@RequestMapping` (в данном 
примере итоговый путь будет равен `http://my.host.com/path/secondary-path`).

`@RequestMapping` может использоваться и на уровне метода-обработчика запроса, с явным указанием HTTP-метода, на который
ориентируется обработчик, например:

```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class MyController {

    @RequestMapping(path = "/", method = RequestMethod.GET)
    public String home() {
        return "home";
    }
    
}
```

Но куда более понятным для чтения и проще для написания является использование по-потребности `@RequestMapping` на
уровне класса с указанием базовой части пути, а у конкретных методов-обработчиков контроллера указывать явные аннотации
для каждого пути (относительно того, что, возможно, указан в `@RequestMapping`) и HTTP-метода:

| Аннотация        | HTTP-метод    |
| ---------------- | ------------- |
| `@GetMapping`    | `HTTP GET`    |
| `@PostMapping`   | `HTTP POST`   |
| `@PutMapping`    | `HTTP PUT`    |
| `@DeleteMapping` | `HTTP DELETE` |
| `@PatchMapping`  | `HTTP PATCH`  |

## Реализация слоя View

Для реализации представления формы создания тако, используется Thymeleaf, как и в 1й главе. Основное изменение: 
передача данных (модели для отображения) от контроллера к представлению - шаблону Thymeleaf. В методе-обработчике
HTTP-запроса в контроллере в качестве аргумента метода выступает объект класса `Model`. В сущности, класс модели -
мапа атрибутов с ключом - именем атрибута. Термин "атрибут" в данном случае идёт от сервлетов, в которых аналогичным
образом, при помощи мапы с атрибутами, передавались данные между методом-обработчиком запросов и JSP-страницей.
По-аналогии, альтернативой JSP-страницам здесь выступает Thymeleaf-шаблоны, которым передаётся объект `Model`.

Thymeleaf использует специальные атрибуты html-тэгов с префиксом `th:`, например:

- `th:text` - подставляет вычисленное значение атрибута в качестве значения тэга, например:

```html
<p th:text="${msg}"></p>
```

Под конструкцией `${...}` понимается вычисление строкового значения от выражения внутри фигурных скобок. `msg` - имя
атрибута запроса (в терминах сервлетов) или ключ-имя атрибута в мапе модели `Model` Spring-а. Таким образом, 
Thymeleaf достаёт из модели объект по ключу-имени `msg` и использует его метод `toString()`.

**Важно**: Thymeleaf не создаёт объектов, т.е. если я хочу передать объект обратно из формы, то аллоцированный объект
уже должен быть добавлен в модель! В противном случае будет получена ошибка. Именно поэтому на примере с формой для
тако в методе обработки `String showDesignForm(Model model)` в `model` отдельно кладётся новый объект `new Taco()` с
ключом-именем `"resultTacoDesign"` (в отличие от книги, я изменил название атрибута, чтобы не путать с названием
возвращаемого шаблона представления).

**Важно**: Изначально было желание использовать в качестве имени атрибута `"result-taco-design"`, но использование имени с `-` внутри с тэгами `th:` интерпретируется [как выражение](https://readthefuckingmanual.net/error/6261)! 

В конце метода-обработчика контроллера возвращается строка - имя View, которое должно вернуться пользователю. 
Возможно, данный метод должен не возвращать свой какой-то View, а перенаправлять пользователя на другой адрес, тогда
требуется в возвращаемой строке указать url (абсолютный или относительный) с префиксом `redirect:`:

```java
return "redirect:https://google.com";
```

Или относительныЙ, если перенаправление должно быть внутри нашего приложения:

```java
return "redirect:/relative/path";
```

### Итерация используя Thymeleaf

Для обхода коллекций можно использовать html-атрибут `th:each="tempVar : ${collection}`. Тэг, внутри которого применён
данный атрибут, будет повторён N раз по количеству элементов в объекте с ключом-именем атрибута модели `collection`. У
каждого тэга будет свой элемент коллекции, к которому можно обратиться через имя `tempVar`. В сущности, работа с 
`th:each` похожа на цикл `foreach` в Java. Пример:

```html
<label th:each="ingredient : ${wrap}">
    <input name="ingredients" type="checkbox" th:value="${ingredient.id}" />
    <span th:text="${ingredient.name}"></span>
    <br />
</label>
```

После разбора данного шаблона на выходе будет следующий HTML-код:

```html
<label>
    <input name="ingredients" type="checkbox" value="FLTO" />
    <span>Flour Tortilla</span>
    <br />
</label>
<label>
    <input name="ingredients" type="checkbox" value="COTO" />
    <span>Corn Tortilla</span>
    <br />
</label>
```

В модели было 2 ингредиента с типом `WRAP` и с ключом в lowercase `wrap`. По данному ключу мы из модели получаем 
список ингредиентов c `id` "FLTO" и "COTO". В качестве метки мы обращались к полю `name` ингредиента. Thymeleaf
вычислил значения всех полей в каждом из ингредиентов и подставил в итоговый HTML-документ. Стоит отметить, что 
`<label>` повторяется вместе со всем его содержимым внутри тэга.

### Отправка формы, используя Thymeleaf

В общем случае, составление формы состоит из 3х элементов:

- Оборачивающего всю форму тэг `<form>...<form/>`. В нём находятся все следующие элементы. Имеет несколько важных 
атрибутов:
  + `method` - HTTP-метод для пересылки формы, может быть `="get"` или `="post"`, в обеих формах использовался второй
случай;
  + `th:object="${myPayloadObject}` - объект, в который будут класться все данные с формы. `myPayloadObject` -
ключ-имя атрибута модели (**Важно**: не забываем, что у этого имени не должно быть чёрточек `-`, а при 
использовании внутри выражения Thymeleaf `${...}` важно чтобы не было лишних пустых символов, вроде пробела, т.к. всё
содержимое фигурных скобок целиком учитывается в качестве ключа-имени атрибута модели);
  + `th:action=@{/my/relative/path}` - относительный путь, по которому будет делаться HTTP-действие из html-атрибута 
`method` (в данному случае по адресу `http://my.host.com/my/relative/path`).

- Тэги ввода информации, например `<input>...<input/>`. Внутри указывается следующие html-атрибуты: 
  + `type`, который указывает какого типа информация будет вводиться от пользователя, например, `="text"` -
однострочное текстовое поле, или `="submit"` - кнопка для отправки объекта с информацией формы (в этом случае
html-атрибут `value="..."` содержит текст на кнопке); 
  + `th:field="*{fieldName}"` для указания имени поля в итоговом объекте формы, в которое будет записано значение,
введёное пользователем в текущий элемент `<input>`. Выражение внутри `*{...}` вычисляется относительно объекта,
определённого ранее в теге `<form th:object=${myPayloadObject} ...`, при желании, можно указать явно обращение к полю
объекта: `th:field="${myPayloadObject.myField}`, эти записи эквиваленты.

- Тэг для создания кнопки для отправки формы `<button>Текст на кнопке</button>`. Данная запись эквивалентна: 
`<input type="submit" value="Текст на кнопке" />`, но использование специального тэга для кнопки в данном случае 
семантически понятнее. По-умолчаню внутри формы тэг `<button>` уже имеет `type="submit"`, если данное поведение
нежелательно, то требуется явно прописать, например, `type="button"` - в таком случае по нажатию на кнопку не будет
автоматически выполнено действие формы.



